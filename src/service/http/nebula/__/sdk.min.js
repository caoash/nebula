import{neb}from"../dist/web/main2.js";import{State}from"./state.min.js";const isType=(t,s)=>typeof t===s,isNumber=t=>isType(t,"number"),isString=t=>isType(t,"string"),isFunction=t=>isType(t,"function"),s=t=>t.map((t=>`${t}`)),log=console.log,except=t=>{throw{message:t}},CT=neb.CustomType,OT=neb.OrderType,RU=neb.Rollup,OP=neb.Operation;export class Nebula{constructor(){this.Type={INT:CT.INT,LONG:CT.LONG,FLOAT:CT.FLOAT,DOUBLE:CT.DOUBLE,STRING:CT.STRING},this.Sort={ASC:OT.ASC,DESC:OT.DESC,NONE:OT.NONE},this.reset=()=>{this.src_="",this.keys_=[],this.metrics_=[],this.start_=0,this.end_=0,this.columns_=[],this.timeline_=!1,this.time_unit_=-1,this.sort_=this.Sort.ASC,this.limit_=100,this.filter_={},this.pivot_="",this.map_=null,this.rm_=[],this.window_=0},this.source=t=>(this.src_=t,this),this.time=(t,s)=>(this.start_=t,this.end_=s,this),this.select=(...args)=>{for(var i=0;i<args.length;++i){const arg=args[i],type=typeof arg;if("string"===type)this.keys_.push(arg);else if("function"===type)this.metrics_.push(eval(arg));else{if("object"!==type)throw`Unsupported field type: ${type}.`;this.metrics_.push(arg)}}return this},this.pivot=t=>(this.keys_.includes(t)&&1===this.metrics_.length||except("pivot existing key for single metric."),this.pivot_=t,this),this.map=(t,...s)=>(this.map_=t?`() => ${t.toString()};`:"",this.rm_=s,this),this.where=t=>(t&&(t.l?this.filter_=t:this.filter_={l:"AND",r:[t]}),this),this.sortby=t=>(this.sort_=t,this),this.limit=t=>(this.limit_=t,this),this.apply=(t,s,i)=>(t&&isString(t)||except("apply - column name required"),(void 0===s||!isNumber(s)||s<this.Type.INT||s>this.Type.STRING)&&except("apply - unsupported type."),i&&isFunction(i)||except("apply - lambda/function required."),this.columns_.push({name:t,type:s,expr:`const ${t} = ${i.toString()};`}),this),this.run=(t,s)=>(this.timeline_=!!t,this.window_=s||0,this),this.timeline=t=>this.run(!0,t),this.validate=()=>this.src_?0===this.start_||0===this.end_?(log(`Invalid time range [${this.start_}, ${this.end_}].`),"Invalid time range."):0===this.keys_.length&&0===this.metrics_.length?"Keys or metrics missing":this.limit_<1?(log(`Invalid limit: ${this.limit_}`),"Invalid limit value."):this.sort_!=this.Sort.ASC&&this.sort_!=this.Sort.DESC&&this.sort_!=this.Sort.NONE?(log(`Invalid sort value: ${this.sort_}`),"Invalid sort option."):null:"Invalid table source.",this.build=()=>{const t=(new State).state_;return t.table=this.src_,t.start=this.start_,t.end=this.end_,t.keys=this.keys_,t.window=this.window_,t.timeline=this.timeline_,t.time_unit=this.time_unit_,t.limit=this.limit_,t.sort=this.sort_,t.metrics=this.metrics_,t.filter=this.filter_,t.customs=this.columns_,q,t.pivot=this.pivot_,t.map=this.map_,t.rm=this.rm_,t}}}export const count=t=>({M:RU.COUNT,C:t,A:t,as:function(t){return this.A=t,this}});export const sum=t=>({M:RU.SUM,C:t,A:t,as:function(t){return this.A=t,this}});export const max=t=>({M:RU.MAX,C:t,A:t,as:function(t){return this.A=t,this}});export const min=t=>({M:RU.MIN,C:t,A:t,as:function(t){return this.A=t,this}});export const avg=t=>({M:RU.AVG,C:t,A:t,as:function(t){return this.A=t,this}});export const tree=t=>({M:RU.TREEMERGE,C:t,A:t,as:function(t){return this.A=t,this}});export const p10=t=>({M:RU.P10,C:t,A:t,as:function(t){return this.A=t,this}});export const p25=t=>({M:RU.P25,C:t,A:t,as:function(t){return this.A=t,this}});export const p50=t=>({M:RU.P50,C:t,A:t,as:function(t){return this.A=t,this}});export const p75=t=>({M:RU.P75,C:t,A:t,as:function(t){return this.A=t,this}});export const p90=t=>({M:RU.P90,C:t,A:t,as:function(t){return this.A=t,this}});export const p99=t=>({M:RU.P99,C:t,A:t,as:function(t){return this.A=t,this}});export const p99_9=t=>({M:RU.P99_9,C:t,A:t,as:function(t){return this.A=t,this}});export const p99_99=t=>({M:RU.P99_99,C:t,A:t,as:function(t){return this.A=t,this}});export const and=(...t)=>0==t.length?{}:{l:"AND",r:t};export const or=(...t)=>0==t.length?{}:{l:"OR",r:t};export const eq=(t,...i)=>(0==i.length&&except("syntax: eq(<column>, val1, val2, ...)"),{c:t,o:OP.EQ,v:s(i)});export const neq=(t,...i)=>(0==i.length&&except("syntax: eq(<column>, val1, val2, ...)"),{c:t,o:OP.NEQ,v:s(i)});export const gt=(t,i)=>({c:t,o:OP.MORE,v:s([i])});export const lt=(t,i)=>({c:t,o:OP.LESS,v:s([i])});export const like=(t,i)=>({c:t,o:OP.LIKE,v:s([i])});export const ilike=(t,i)=>({c:t,o:OP.ILIKE,v:s([i])});export const unlike=(t,i)=>({c:t,o:OP.UNLIKE,v:s([i])});export const iunlike=(t,i)=>({c:t,o:OP.IUNLIKE,v:s([i])});