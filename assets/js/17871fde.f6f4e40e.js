"use strict";(self.webpackChunknebula=self.webpackChunknebula||[]).push([[820],{1279:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return r},contentTitle:function(){return l},metadata:function(){return u},assets:function(){return c},toc:function(){return p},default:function(){return d}});var a=n(7462),i=n(3366),s=(n(7294),n(3905)),o=["components"],r={layout:"default"},l="Expression, UDF, and UDAF",u={permalink:"/blog/2021/03/01/expression_udf_udaf",source:"@site/blog/2021-03-01-expression_udf_udaf.md",title:"Expression, UDF, and UDAF",description:"Nebula analytics relies on aggregations, and these aggregations are expressed by",date:"2021-03-01T00:00:00.000Z",formattedDate:"March 1, 2021",tags:[],readingTime:2.405,truncated:!1,authors:[],prevItem:{title:"Custom Column - Instant UDF",permalink:"/blog/2021/04/01/custom_column"},nextItem:{title:"Sketch: extensible customized aggregation",permalink:"/blog/2021/02/01/sketch"}},c={authorsImageUrls:[]},p=[{value:"AVG",id:"avg",children:[]},{value:"Percentiles, NDV and others",id:"percentiles-ndv-and-others",children:[]}],m={toc:p};function d(e){var t=e.components,r=(0,i.Z)(e,o);return(0,s.kt)("wrapper",(0,a.Z)({},m,r,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Nebula")," analytics relies on aggregations, and these aggregations are expressed by"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Expressions: including constant ops, arthmetic ops, logical ops and column ops.\nThese operations are basics for a programing language, hence they are fundementals to nebula query engine.   "),(0,s.kt)("li",{parentName:"ul"},'UDF: nebula will provide native UDFs in its own package implemented with native code.\nWe plan to add customized UDF through user interface which will be available in javascript. V8 engine will be used to execute them with interopability with Nebula runtime data strucutre.\nBasic built-in UDFs are "in", "not in", "like", "ilike", etc.'),(0,s.kt)("li",{parentName:"ul"},'UDAF: core analytic capability are supported by "aggregation metrics by dimensions".\nNebula provides efficient implementations for them, UDAF like "count", "sum", "avg", "median", "percentiles", "NDV" shall be available.')),(0,s.kt)("p",null,"Plug-in a new UDF / UDAF should be straigtforward in nebula code base, feel free to submit a new request through issue or PR. "),(0,s.kt)("h2",{id:"avg"},"AVG"),(0,s.kt)("p",null,'UDAF "avg" is an interesting topic, I have been thinking a lot on how to implement it.\nBasically there are two major approaches (well essentially the same concept)\n1) Having SUM / COUNT columns in computing time and convert to AVG column at the last step.\nIn this approach, we flex the schema and operate in query level.\n2) Have "special" column type such as a binary buffer or wider type like int128.\nIt is similar to number 1 in terms of flexing schema, but it doesn\'t change column count.'),(0,s.kt)("p",null,"I think #1 provides pretty generic solution for many similar problem - extend data store in runtime by adding more columns. #2 sounds a bit hacky, but because it maintains same width of schema, a lot of checks and type converts becoming naturely easy. So in the first try, I chose to implement AVG using #2 approach without changing much on the query planning itself."),(0,s.kt)("p",null,'A very important data structure used in Nebula is called "HashFlat", it\'s basically a row-based data set with hash function to keep unique rows in contingious memory block. It needs client to provide interfaces to process data in different type:'),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Store:    convert UDAF inner expression value into the store type in hash flat."),(0,s.kt)("li",{parentName:"ul"},"Merge:    merge two rows with same keys."),(0,s.kt)("li",{parentName:"ul"},"Finalize: convert store type into desired type.")),(0,s.kt)("p",null,"A UDAF will define these 3 functions, and when a hash flat is setup, a wrapper of this function set will be provided.\nSo when HashFlat receives a duplicate rows (same keys), it will trigger the merge function, and new row to trigger store method, for most cases, since store type equals native type, it will have empty store and finalize method.\n",(0,s.kt)("img",{alt:"UDF + Types",src:n(4738).Z})),(0,s.kt)("h2",{id:"percentiles-ndv-and-others"},"Percentiles, NDV and others"),(0,s.kt)("p",null,"Follow the same pattern, for any UDAF that requires state management, it can go the same design as AVG using a store type for state management and use finalize method to convert temporary state to final value."))}d.isMDXComponent=!0},4738:function(e,t,n){t.Z=n.p+"assets/images/udf.types-60d1101e2b3972371056caf7d65642d2.png"}}]);