"use strict";(self.webpackChunknebula=self.webpackChunknebula||[]).push([[410],{3905:function(e,t,a){a.d(t,{Zo:function(){return m},kt:function(){return d}});var n=a(7294);function l(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){l(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function r(e,t){if(null==e)return{};var a,n,l=function(e,t){if(null==e)return{};var a,n,l={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(l[a]=e[a]);return l}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(l[a]=e[a])}return l}var s=n.createContext({}),u=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},m=function(e){var t=u(e.components);return n.createElement(s.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},p=n.forwardRef((function(e,t){var a=e.components,l=e.mdxType,i=e.originalType,s=e.parentName,m=r(e,["components","mdxType","originalType","parentName"]),p=u(a),d=l,f=p["".concat(s,".").concat(d)]||p[d]||c[d]||i;return a?n.createElement(f,o(o({ref:t},m),{},{components:a})):n.createElement(f,o({ref:t},m))}));function d(e,t){var a=arguments,l=t&&t.mdxType;if("string"==typeof e||l){var i=a.length,o=new Array(i);o[0]=p;var r={};for(var s in t)hasOwnProperty.call(t,s)&&(r[s]=t[s]);r.originalType=e,r.mdxType="string"==typeof e?e:l,o[1]=r;for(var u=2;u<i;u++)o[u]=a[u];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}p.displayName="MDXCreateElement"},6970:function(e,t,a){a.r(t),a.d(t,{frontMatter:function(){return r},contentTitle:function(){return s},metadata:function(){return u},toc:function(){return m},default:function(){return p}});var n=a(7462),l=a(3366),i=(a(7294),a(3905)),o=["components"],r={layout:"default"},s="Common Configs",u={unversionedId:"configs/common",id:"configs/common",isDocsHomePage:!1,title:"Common Configs",description:"If you have seen the examples in basics/overview, you probably already know how to add a configs to connect different data sources from Nebula.",source:"@site/docs/configs/1-common.md",sourceDirName:"configs",slug:"/configs/common",permalink:"/docs/configs/common",tags:[],version:"current",sidebarPosition:1,frontMatter:{layout:"default"},sidebar:"defaultSidebar",previous:{title:"Service discovery",permalink:"/docs/basics/discovery"},next:{title:"Data Formats",permalink:"/docs/configs/formats"}},m=[{value:"Config Structure",id:"config-structure",children:[]},{value:"Resource Constraints",id:"resource-constraints",children:[]},{value:"Schema",id:"schema",children:[]},{value:"Data, Loader, Source, Backup, Format",id:"data-loader-source-backup-format",children:[]},{value:"Time",id:"time",children:[]},{value:"Settings",id:"settings",children:[]}],c={toc:m};function p(e){var t=e.components,a=(0,l.Z)(e,o);return(0,i.kt)("wrapper",(0,n.Z)({},c,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"common-configs"},"Common Configs"),(0,i.kt)("p",null,"If you have seen the examples in basics/overview, you probably already know how to add a configs to connect different data sources from Nebula."),(0,i.kt)("p",null,"In this section, we will list all common configs and explain thier usage."),(0,i.kt)("h2",{id:"config-structure"},"Config Structure"),(0,i.kt)("p",null,"The whole cluster config is a yaml file which you specified for NebulaServer to start with (eg. ",(0,i.kt)("inlineCode",{parentName:"p"},"--CLS_CONF cluster.yaml"),"), in the config, there are just a few major sections:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"version"),": version value of the config"),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"server"),": the nebula cluster settings, useful sub-configs are:",(0,i.kt)("ol",{parentName:"li"},(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"anode"),': boolean value - treat nebula server as one of the normal nebula node, default to "false".'),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"auth"),': boolean value - indicating if nebula query execution will enforce auth check. If set true, the necessary auth model needs to be set up in the same config, check basics/access_control for details, default to "false".'),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"meta"),": specify what metadata tracking service to use, it's either an external meta db service or the built-in one implemented using LevelDB + cloud storage (such as S3) for data persistence. It can be used to store nebula shortened URL and some other server running metrics, default to none.")),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-yaml"}," # configure meta db as none\n meta:\n   db: none\n")),"or ",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-yaml"}," # use the built-in metadb and use s3://nebula/meta as the data store.\n meta:\n   db: native\n   store: s3://nebula/meta\n")),(0,i.kt)("ol",{parentName:"li",start:4},(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"discovery"),": config how nebula cluster is discover each other between Nebula Server and Nebula Nodes. Only two options provided so far, check basics/discovery for details.")),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-yaml"},"  # most common way - let nebula nodes connect nebula server an self-register itself\n  discovery:\n   method: service\n")),"or ",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-yaml"}," # useful for static setup with known address for all nebula nodes\n discovery:\n   method: config\n")),"when ",(0,i.kt)("inlineCode",{parentName:"li"},"method: config")," is specified, all nebula nodes needs to configured in this same config file, as shown in the next config"),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"nodes"),": configs to list all static nebula nodes, this is only used when discover/method specified as ",(0,i.kt)("inlineCode",{parentName:"li"},"config"),", here is an example:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml"},"# will be provided by environment\nnodes:\n  - node:\n      host: neula.node.1\n      port: 9199\n  - node:\n      host: neula.node.2\n      port: 9199\n")),(0,i.kt)("ol",{start:4},(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"tables"),": this is the most active configured section to add/change/update all the data sources available for current nebula cluster. It includes all tables definition.\nA table could be backed by a cloud storage location, could be backed by a real time streaming, could be even backed by a HTTP API endpoint or simply a data service like Google Spreadsheet.\nThis config will also include ",(0,i.kt)("inlineCode",{parentName:"li"},"data format")," settings (csv, json, thrift, parquet, spreadsheet, ...) as well as ",(0,i.kt)("inlineCode",{parentName:"li"},"data rolling policy"),".")),(0,i.kt)("p",null,"We will use following documentations to describe each different ways to connect different data source."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml"},"tables:\n  table-name-1:\n    {configs}\n  table-name-2:\n    {configs}\n  ...\n")),(0,i.kt)("h2",{id:"resource-constraints"},"Resource Constraints"),(0,i.kt)("p",null,"For each table, we can define resource constraints for it, this is required for rolling tables, so that Nebula only keeps the most recent data in memory, data past the contraints will be either erased or backup for future query."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"retention")," is used to specify maximum size and maximum time window for the table, whichever reaches firstly, nebula will purge out the old data segments."),(0,i.kt)("p",null,"Let's take a look at one example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml"},"tables:\n  table-name-1:\n    retention:\n      max-mb: 10000\n      max-hr: 0.5\n")),(0,i.kt)("p",null,"This config asks nebula cluster to keep maximum 10GB of data for ",(0,i.kt)("inlineCode",{parentName:"p"},"table-name-1"),", or maximum half an hour of the data if applicable. For real time streaming, this means, Nebula serves ",(0,i.kt)("inlineCode",{parentName:"p"},"last 30minutes")," of data."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"max-mb"),": MegaBytes - an integer."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"max-hr"),": hours - an double, converted to seconds internally.")),(0,i.kt)("h2",{id:"schema"},"Schema"),(0,i.kt)("p",null,"Schema is needed for every single table definition, regardless where the data is coming from or what the data format is. It's defined in a string of serialized format of schema."),(0,i.kt)("p",null,"Here is an exmaple:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml"},'tables:\n  table-name-1:\n    schema: "ROW<id:int, event:string, tag:string, items:list<string>, flag:bool, value:tinyint>"\n')),(0,i.kt)("p",null,"Basically, it is a collection of ",(0,i.kt)("inlineCode",{parentName:"p"},"name:type"),". Nebula is ",(0,i.kt)("inlineCode",{parentName:"p"},"hive")," data types compatible, so here is the list supported, some type has multiple aliaes, whichever alias you use, it's effectively the same:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"bool, boolean"),(0,i.kt)("li",{parentName:"ol"},"tinyint, byte, char"),(0,i.kt)("li",{parentName:"ol"},"smallint, short"),(0,i.kt)("li",{parentName:"ol"},"int, integer"),(0,i.kt)("li",{parentName:"ol"},"bigint, long"),(0,i.kt)("li",{parentName:"ol"},"real, float"),(0,i.kt)("li",{parentName:"ol"},"double, decimal"),(0,i.kt)("li",{parentName:"ol"},"int128"),(0,i.kt)("li",{parentName:"ol"},"varchar, string, binary"),(0,i.kt)("li",{parentName:"ol"},"array, list, vector"),(0,i.kt)("li",{parentName:"ol"},"map, dictionary"),(0,i.kt)("li",{parentName:"ol"},"row, struct")),(0,i.kt)("p",null,"Note that, compound types like array/map/struct are not well tested so far."),(0,i.kt)("h2",{id:"data-loader-source-backup-format"},"Data, Loader, Source, Backup, Format"),(0,i.kt)("p",null,"These are common configs for each table definition, depending on different type of data, their values vary a lot."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"data"),": this defines data source type, it could be one of these supported types - "),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"s3"),": data from AWS S3 "),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"gs"),": data from Google Cloud Storage"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"kafka"),": data from kafka real time streaming."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"local"),": data from a local file system (mostly used for single node testing)"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"http"),": data from a HTTP endpoint"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"loader"),": this config indicates how Nebula loads data into nebula cluster, it's high level data ingestion policy, here are some possible values:"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Swap"),": the table has one location to read data from, whever it changes, Nebula swaps new data in."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Roll"),": this is mostly used, it ask Nebula to compute how many different locations it could read data from under the ",(0,i.kt)("inlineCode",{parentName:"li"},"Resource Contraints"),", and generate ingestion specs to roll data in, it will evict old data past the contraints and ingest new data in whenever it's available."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Api"),": used mostly for on-demand data loading when a client use API to ask Nebula to load some data"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"source"),": source is usually address, path or location template."))),(0,i.kt)("p",null,"for example, a S3 data could define source like below"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml"},"tables:\n  table-name-1:\n    data: s3\n    loader: Roll\n    source: s3://bucket/path/%7BDATE%7D/part=abc/\n    backup: s3://nebula/n107/\n    format: parquet\n")),(0,i.kt)("p",null,"this definition asks Nebula to load data from path ",(0,i.kt)("inlineCode",{parentName:"p"},"s3://bucket/path/%7BDATE%7D/part=abc/")," with ",(0,i.kt)("inlineCode",{parentName:"p"},"DATE")," as a macro to compute real path based on ",(0,i.kt)("inlineCode",{parentName:"p"},"max-hr")," definition from resource contraints, and the data has ",(0,i.kt)("inlineCode",{parentName:"p"},"parquet")," file format, under the folder, there are one or more parquet files."),(0,i.kt)("p",null,"another example, let's look at how Kafka works"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml"},"tables:\n  table-name-1:\n    data: kafka\n    topic: topic-1\n    loader: Roll\n    source: <brokers>\n    backup: s3://nebula/n116/\n")),(0,i.kt)("p",null,"in this case, ",(0,i.kt)("inlineCode",{parentName:"p"},"source")," is used to place Kafka broker list that Nebula could connect to fetch data from ",(0,i.kt)("inlineCode",{parentName:"p"},"topic-1"),"."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"backup"),": is always an accessible location where Nebula can backup the data to when those data become evictable due to resource contraints. Nebula doesn't practice this often till today, maybe supported much better in the future when it seeks support for querying historical data.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"format"),": data format - the wide range and growing data format to support in Nebula so that we can ingest all types of data sources and query it in a single interface. Till writing time, the supported formats include:"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"CSV"),(0,i.kt)("li",{parentName:"ul"},"JSON"),(0,i.kt)("li",{parentName:"ul"},"THRIFT"),(0,i.kt)("li",{parentName:"ul"},"PARQUET"),(0,i.kt)("li",{parentName:"ul"},"GOOGLE SHEET")))),(0,i.kt)("p",null,'We will expand the format specific settings in the post for "data format".'),(0,i.kt)("h2",{id:"time"},"Time"),(0,i.kt)("p",null,"Time section is very important - as it impacts how Nebula organize the data internally, Nebula has an implicit built-in time column (",(0,i.kt)("inlineCode",{parentName:"p"},"_time_"),") which is available for every single table.\nAlso for most rolling data, they rely on ",(0,i.kt)("inlineCode",{parentName:"p"},"time")," definition to materialize those time related macro to compute real data location to read data from."),(0,i.kt)("p",null,"Similarily, let's use examples to explain all different ways to define time."),(0,i.kt)("p",null,"Example 1: use a static value for time"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml"},"tables:\n  table-name-1:\n    time:\n      type: static\n      value: 1571875200\n")),(0,i.kt)("p",null,"Value is specfified as unix time in seconds, in this case, all table rows will have the same value."),(0,i.kt)("p",null,"Example 2: use current time"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml"},"tables:\n  table-name-1:\n    time:\n      type: current\n")),(0,i.kt)("p",null,"Only type is needed, Nebula will put ingestion time of each row to its ",(0,i.kt)("em",{parentName:"p"},"time")," column."),(0,i.kt)("p",null,"Example 3: use a column value as ",(0,i.kt)("em",{parentName:"p"},"time")," column"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml"},"tables:\n  table-name-1:\n    time:\n      type: column\n      column: col2\n      pattern: UNIXTIME_NANO\n")),(0,i.kt)("p",null,"In this case, Nebula will convert an existing column into the value of ",(0,i.kt)("em",{parentName:"p"},"time")," column. For this type, column name is needed and value pattern is needed as well for a successful conversion."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"column"),': the column name from "schema" definition discussed previously.'),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"pattern"),": the supported time value format for correct conversion, this includes:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},'"UNIXTIME": column value is ',(0,i.kt)("inlineCode",{parentName:"li"},"unix time in seconds"),"."),(0,i.kt)("li",{parentName:"ul"},'"UNIXTIME_MS": column value is ',(0,i.kt)("inlineCode",{parentName:"li"},"unix time in milli seconds"),"."),(0,i.kt)("li",{parentName:"ul"},'"UNIXTIME_NANO": column value is ',(0,i.kt)("inlineCode",{parentName:"li"},"unix time in nano seconds"),"."),(0,i.kt)("li",{parentName:"ul"},'"SERIAL_NUMBER": column value is in ',(0,i.kt)("inlineCode",{parentName:"li"},"serial number")," format which is usually defined by excel or google spreadsheet data."),(0,i.kt)("li",{parentName:"ul"},'"C++ time format": string pattern which Nebula uses "std::get_time" to convert, such as "%m/%d/%Y %H:%M:%S", or "%Y-%m-%d", check pattern details ',(0,i.kt)("a",{parentName:"li",href:"https://en.cppreference.com/w/cpp/io/manip/get_time"},"https://en.cppreference.com/w/cpp/io/manip/get_time"))))),(0,i.kt)("p",null,"Example 4: use macro value for time column\nTo support rolling data source from a cloud storage, Nebula supports list of macros from its source template, which is usually constructed by different time units."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml"},"  nebula.daily:\n    # the source has supported macro in it\n    source: s3://nebula/ephemeral/dt=%7Bdate%7D/\n    time:\n      type: macro\n      pattern: daily\n")),(0,i.kt)("p",null,"In this case, Nebula will generate real source like ",(0,i.kt)("inlineCode",{parentName:"p"},"s3://nebula/ephemeral/dt=2021-01-01/"),", and use day time level value to set its ",(0,i.kt)("em",{parentName:"p"},"time")," column which is equivalent to ",(0,i.kt)("inlineCode",{parentName:"p"},"2021-01-01"),"."),(0,i.kt)("p",null,"Similarily, all supported granularity of time macros in path could be combination of these:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"DATE"),(0,i.kt)("li",{parentName:"ul"},"HOUR"),(0,i.kt)("li",{parentName:"ul"},"MINUTE"),(0,i.kt)("li",{parentName:"ul"},"SECOND")),(0,i.kt)("h2",{id:"settings"},"Settings"),(0,i.kt)("p",null,"Lastly, Nebula has a very generic config called ",(0,i.kt)("inlineCode",{parentName:"p"},"settings"),", this will be used as extension to accept any key-value pairs to impact Nebula behavior for the defined table. Both key and value are in string value, though sometimes we use a JSON string to hold a structure for more complex configurations. "),(0,i.kt)("p",null,'We will touch these "misc" configs while talking about other scenarios.'))}p.isMDXComponent=!0}}]);