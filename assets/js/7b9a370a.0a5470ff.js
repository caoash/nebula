"use strict";(self.webpackChunknebula=self.webpackChunknebula||[]).push([[867],{1884:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return s},contentTitle:function(){return l},metadata:function(){return p},assets:function(){return u},toc:function(){return d},default:function(){return h}});var i=n(7462),o=n(3366),a=(n(7294),n(3905)),r=["components"],s={},l="BigInt Problem",p={permalink:"/blog/2020/09/01/bigint",source:"@site/blog/2020-09-01-bigint.md",title:"BigInt Problem",description:"We know that Javascript can only represent 2^53-1 as it max number. For any values larger than that will lose precision during data exchange in javascript runtime. Most of the time, we have to pay cost to serializing 64bits in string format.",date:"2020-09-01T00:00:00.000Z",formattedDate:"September 1, 2020",tags:[],readingTime:2.33,truncated:!1,authors:[],prevItem:{title:"Web UI",permalink:"/blog/2021/01/01/web_ui"}},u={authorsImageUrls:[]},d=[{value:"No 1. rapidjson",id:"no-1-rapidjson",children:[]},{value:"No 2. node.js",id:"no-2-nodejs",children:[]},{value:"No 3. web",id:"no-3-web",children:[]},{value:"No 4. other clients.",id:"no-4-other-clients",children:[]}],c={toc:d};function h(e){var t=e.components,n=(0,o.Z)(e,r);return(0,a.kt)("wrapper",(0,i.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"We know that Javascript can only represent 2^53-1 as it max number. For any values larger than that will lose precision during data exchange in javascript runtime. Most of the time, we have to pay cost to serializing 64bits in string format."),(0,a.kt)("p",null,"Nebula faces this issue too, in this short note, I would just like to summarize all places with the concern and how we handle them for now, this doesn't mean it is ideal, in fact, we are still looking for improvements. "),(0,a.kt)("h2",{id:"no-1-rapidjson"},"No 1. rapidjson"),(0,a.kt)("p",null,"We have been using RapidJson as the JSON serde library in our C++ runtime, due to its capability handling this concern well.\nWe don't do ",(0,a.kt)("inlineCode",{parentName:"p"},"long<--\x3estring")," conversion trick. Hence we removed similar trick in your code base, specifically in InExpression serde code path."),(0,a.kt)("h2",{id:"no-2-nodejs"},"No 2. node.js"),(0,a.kt)("p",null,"node.js is the web server runtime ",(0,a.kt)("inlineCode",{parentName:"p"},"Nebula Web")," resides in, it is definitely the most hot place regarding this issue. We have been using JSON as data fromat to exchange requests/responses between ",(0,a.kt)("inlineCode",{parentName:"p"},"web client")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"Nebula Server"),".  Here are what we have done:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"We're using json-bigint package to do ",(0,a.kt)("inlineCode",{parentName:"li"},"json.parse")," so if the input JSON includes bigint values, it won't lose the value're precision."),(0,a.kt)("li",{parentName:"ol"},"In nebula proto, we added two more types of predicate, so it allows client to use one of them",(0,a.kt)("ol",{parentName:"li"},(0,a.kt)("li",{parentName:"ol"},"value: string type "),(0,a.kt)("li",{parentName:"ol"},"nvalue: int64 type"),(0,a.kt)("li",{parentName:"ol"},"dvalue: double type.")))),(0,a.kt)("p",null,"with this change, we don't pay string->int or string->double type data conversion. (In fact, protobuf does this for us - it is uncertain if perf is better, but at least cleaner at interface)."),(0,a.kt)("p",null,"The serde work is dene by protobuf-js, which is still using ",(0,a.kt)("inlineCode",{parentName:"p"},"Number")," for all number values, so the problem still exists, if passing bigint value in ",(0,a.kt)("inlineCode",{parentName:"p"},"grpc")," call defined by int64 in ",(0,a.kt)("inlineCode",{parentName:"p"},"nebula.proto"),", Nebula Server may receive wrong value. And I haven't seen this is going to be fixed soon anywhere. We will keep eyes open for any alternative solution."),(0,a.kt)("p",null,'As a work-around, we will use "string" representation for ',(0,a.kt)("inlineCode",{parentName:"p"},"nvalue")," by appending ",(0,a.kt)("inlineCode",{parentName:"p"},"[jstype = JS_STRING]")," in its proto declaration. After that, we requires client to send string list for this field for now. Definitely this is neither convinient nor efficient."),(0,a.kt)("h2",{id:"no-3-web"},"No 3. web"),(0,a.kt)("p",null,"In ",(0,a.kt)("inlineCode",{parentName:"p"},"Nebula UI")," which means browser here, we haven't handle any thing like this, since it is for display purpose, basically all bigint values are returned in ",(0,a.kt)("inlineCode",{parentName:"p"},"string")," type. Client code (browser js) needs to convert it if used in further computation."),(0,a.kt)("h2",{id:"no-4-other-clients"},"No 4. other clients."),(0,a.kt)("p",null,"This is obvious but just to mention, other clients that is not executing in javascript runtime should not have this issue, for example, if I use ",(0,a.kt)("inlineCode",{parentName:"p"},"curl")," to post a JSON blob of bigint array, ",(0,a.kt)("inlineCode",{parentName:"p"},"Nebula API")," (node.js) won't lose precision of values. Other clients like Java should be fine too."))}h.isMDXComponent=!0}}]);