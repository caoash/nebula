"use strict";(self.webpackChunknebula=self.webpackChunknebula||[]).push([[135],{5993:function(e,t,a){a.r(t),a.d(t,{frontMatter:function(){return r},contentTitle:function(){return s},metadata:function(){return u},toc:function(){return c},default:function(){return d}});var n=a(7462),i=a(3366),l=(a(7294),a(3905)),o=["components"],r={layout:"default"},s="Overview",u={unversionedId:"basics/overview",id:"basics/overview",isDocsHomePage:!1,title:"Overview",description:"Nebula is a block based data engine designed for optimizations on",source:"@site/docs/basics/1-overview.md",sourceDirName:"basics",slug:"/basics/overview",permalink:"/docs/basics/overview",tags:[],version:"current",sidebarPosition:1,frontMatter:{layout:"default"},sidebar:"defaultSidebar",previous:{title:"Tutorial Intro",permalink:"/docs/intro"},next:{title:"Security - Access Control",permalink:"/docs/basics/access_control"}},c=[{value:"Security &amp; Privacy",id:"security--privacy",children:[{value:"Column Level Access Control",id:"column-level-access-control",children:[]},{value:"Data Anonymization",id:"data-anonymization",children:[]},{value:"Data Masking",id:"data-masking",children:[]},{value:"Data Encryption",id:"data-encryption",children:[]}]},{value:"Query System",id:"query-system",children:[{value:"Query Execution",id:"query-execution",children:[]},{value:"UDF",id:"udf",children:[]},{value:"Visualization",id:"visualization",children:[]},{value:"JOIN",id:"join",children:[]}]},{value:"Streaming Interface",id:"streaming-interface",children:[]},{value:"Type System",id:"type-system",children:[{value:"Schema Evolution &amp; Backward Compability",id:"schema-evolution--backward-compability",children:[]}]},{value:"Metadata System",id:"metadata-system",children:[]},{value:"Data Encoding Options",id:"data-encoding-options",children:[]}],m={toc:c};function d(e){var t=e.components,r=(0,i.Z)(e,o);return(0,l.kt)("wrapper",(0,n.Z)({},m,r,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("h1",{id:"overview"},"Overview"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Nebula")," is a ",(0,l.kt)("em",{parentName:"p"},"block based data engine")," designed for optimizations on"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Extremely Fast Data Analytics."),(0,l.kt)("li",{parentName:"ul"},"Tiered Data Storage."),(0,l.kt)("li",{parentName:"ul"},"Secured Data Surface.")),(0,l.kt)("p",null,"I would like to highlight a few top advantages that ",(0,l.kt)("strong",{parentName:"p"},"Nebula")," is presenting"),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},"Hybrid columnar storage: depending on scenarios, ",(0,l.kt)("strong",{parentName:"li"},"Nebula")," dynamically switches between row-format and columar format data layout for speeding up computing or maximize throughput. For scenarios like data anonymization or data masking, ",(0,l.kt)("strong",{parentName:"li"},"Nebula")," may even choose pure columnar storage to minimize delta update to alter a specific column data."),(0,l.kt)("li",{parentName:"ol"},"Comprehensive meta data system: meta data system is the brain of the whole system, query optimization, tiered data placement strategy and all other data synchronization are heavily depending on meta data system."),(0,l.kt)("li",{parentName:"ol"},"Dynamic compression/encoding: to fit different access pattern, apply dynamic compression/encoding on different data for best compute efficiency and storage efficiency balance."),(0,l.kt)("li",{parentName:"ol"},"Query interface and streaming interface: no matter it's analytics use case or data streaming use cases. The unified input as query interface, while unified output as streaming interface.")),(0,l.kt)("h1",{id:"architecture"},"Architecture"),(0,l.kt)("p",null,"To fit Nebula into the most common big data system, it could be partially illustrated as:\n",(0,l.kt)("img",{alt:"Nebula",src:a(2574).Z})),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"security--privacy"},"Security & Privacy"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"For an organization, one of the most specific needs in big data system comparing to others is security and privacy requirements."),(0,l.kt)("p",{parentName:"blockquote"},"Connecting with the organization's authentication and authorization system is highly customized in Nebula.\nIt operates as plugin model with a common interface. ")),(0,l.kt)("h3",{id:"column-level-access-control"},"Column Level Access Control"),(0,l.kt)("p",null,"Nebula data gateway requires user principal or access token to query Nebula service interface. The engine itself connects with customized authorization engine to retrieve access rules to decide reactions (pass, reject, masking, repalcement) on given actions (read/write on columns). "),(0,l.kt)("p",null,"This provides a unified way to control data access in a fine-grained granularity."),(0,l.kt)("p",null,"Here is a detailed post explaining how access control works and how it looks, check it out...\n",(0,l.kt)("a",{parentName:"p",href:"/docs/basics/access_control"},"Nebula Access Control")),(0,l.kt)("h3",{id:"data-anonymization"},"Data Anonymization"),(0,l.kt)("p",null,"Reacting to retention policy of specific data, organizaitons which conduct online business are usually required to manage data properly so that they are following users' intention of how their data could be used. Anonymization is one approach to remove specific information but leaving statistical data for ML or analytics purpose."),(0,l.kt)("h3",{id:"data-masking"},"Data Masking"),(0,l.kt)("p",null,"Lots of times, depending on access rules, not like anonymizaiton on data in storage itself, we want to replace hide or replace values of a specific column, we adopt masking techniques to fully or partially return data in acceptable format without change storage, some examples:"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:"left"},"Example Column"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Return Values"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"email"),(0,l.kt)("td",{parentName:"tr",align:"left"},(0,l.kt)("a",{parentName:"td",href:"mailto:xxx@gmail.com"},"xxx@gmail.com"))),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"phone"),(0,l.kt)("td",{parentName:"tr",align:"left"},"206-556-****")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"password"),(0,l.kt)("td",{parentName:"tr",align:"left"},"NULL")))),(0,l.kt)("h3",{id:"data-encryption"},"Data Encryption"),(0,l.kt)("p",null,"Data encryption is one option to allow people to access data with access key.\nThis could be widely used by situations where rules engine is missing configured but allow anybody who has specific access token to access some columns."),(0,l.kt)("h2",{id:"query-system"},"Query System"),(0,l.kt)("p",null,"At the topmost layer, Nebula provide a SQL like DSL API for client to build up queries.\nA query can then be planned and sent to all nebula nodes to execute.\nIt's easy to introduce SQL language as user interface to compile a text-based query into this API."),(0,l.kt)("p",null,"Query Planner will take this query object, compile it into an execution plan to execute.\nA code snippet showing how to build a query object."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},'const auto query = table(tbl, ms)\n                      .where(like(col("event"), "NN%"))\n                      .select(\n                        col("event"),\n                        col("flag"),\n                        max(col("id") * 2).as("max_id"),\n                        min(col("id") + 1).as("min_id"),\n                        count(1).as("count"))\n                      .groupby({ 1, 2 })\n                      .sortby({ 5 }, SortType::DESC)\n                      .limit(10);\n')),(0,l.kt)("h3",{id:"query-execution"},"Query Execution"),(0,l.kt)("p",null,"As we see how data is organized in nebula, we can quickly understand how query is executed, Nebula is a block-based data management system.\nHence a block is not only the smallest chunk of data, it is also the smallest unit in compute parallism. "),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Execution Model",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Fan-out execution to nodes according to planning on metadata. "),(0,l.kt)("li",{parentName:"ul"},"Partial aggregation at node level"),(0,l.kt)("li",{parentName:"ul"},"Global aggregation at query level")))),(0,l.kt)("p",null,"This raw draw shows the flow of query execution\n",(0,l.kt)("img",{alt:"Query Execution Flow",src:a(2983).Z})),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"CPU cache friendly memory management",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Please refer related posts (future links) about the Nebula memory managment for its advantage on speed-up query.")))),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Vectorization and SIMD",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Nebula embraces fully vectorization computing and SIMD instructions."),(0,l.kt)("li",{parentName:"ul"},"This is benefiting from its flexible memory format from ROW orientation to pure columnar orientation."),(0,l.kt)("li",{parentName:"ul"},"Please refer related posts (future links) about the details of Nebula compute style for best speed.")))),(0,l.kt)("h3",{id:"udf"},"UDF"),(0,l.kt)("p",null,"Nebula supports two types of UDFs."),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Built-in UDFs: universal common UDFs are supported natively, these includes but not limited to",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Basic Aggregations: COUNT, SUM, AVG"),(0,l.kt)("li",{parentName:"ul"},"Top: Min, Max"),(0,l.kt)("li",{parentName:"ul"},"Percentiles: Px (P25, P50, P90, P99, etc.)"),(0,l.kt)("li",{parentName:"ul"},"Cardinality: NDV (dictinct values), "),(0,l.kt)("li",{parentName:"ul"},"Others. (Please refer future Nebula Doc for details)"))),(0,l.kt)("li",{parentName:"ul"},"User-provded Javascript Based UDF",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"V8 engine integration."),(0,l.kt)("li",{parentName:"ul"},"Generic row orientied interface to produce new columns."),(0,l.kt)("li",{parentName:"ul"},"User can edit these type of UDF as part of thier interactive queries.")))),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},'  const my_udf = (row) => {\n    // extract values\n    let yValue = row.getString("column_y");\n    if(yValue == "abc"){\n      yValue = "NN";\n    }else if(yValue == "xyz"){\n      yValue = "NNNN";\n    }\n\n    // produce new columns\n    return {\n      "ncolumn_1": row.getInt("column_x") * 20,\n      "ncolumn_2": yValue\n    };\n  };\n\n')),(0,l.kt)("h3",{id:"visualization"},"Visualization"),(0,l.kt)("p",null,"Nebula provides its own UI besides its API to provide tools for users to explore and visualize the data for meanings.\nIn addition to the native visualizaiton methods such as "),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Timeline"),(0,l.kt)("li",{parentName:"ul"},"Table"),(0,l.kt)("li",{parentName:"ul"},"Common charts like Bar, Pie, Line")),(0,l.kt)("p",null,"Nebual also allows plugging different visualization engine to visualize query results, one outstanding example is Sanddance open sourced by Microsoft."),(0,l.kt)("h3",{id:"join"},"JOIN"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"Nebula doesn't support common JOIN as it is designed as storage layer rather than a generic compute engine.\nHowever, some special super fast JOIN nebula considers to support in the future, such as Partitioned Hash Join.\n(We will update this section when related work is initialized.)")),(0,l.kt)("h2",{id:"streaming-interface"},"Streaming Interface"),(0,l.kt)("p",null,"Nebula supports streaming data over gRPC/HTTP2 stack of given query in below format"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Exchangable Data Format",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"(NBlock) Nebula Block"),(0,l.kt)("li",{parentName:"ul"},"Arrow: high exchangable across multiple languages."))),(0,l.kt)("li",{parentName:"ul"},"JSON",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Optimization for light weight data to build UI"))),(0,l.kt)("li",{parentName:"ul"},"Protobuf",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Optimization for application clients")))),(0,l.kt)("h2",{id:"type-system"},"Type System"),(0,l.kt)("p",null,"Nebula treat schema as a type tree. Each leaf node is a primitive data node.\nNon-leaf nodes represents compound types such as struct, list and map.\nThis type system is compatible with hadoop supported data schemas.\n",(0,l.kt)("img",{alt:"Nebula Type Tree",src:a(6905).Z}),"\n",(0,l.kt)("img",{alt:"Nebula Block Memory Layout Example",src:a(6292).Z})),(0,l.kt)("h3",{id:"schema-evolution--backward-compability"},"Schema Evolution & Backward Compability"),(0,l.kt)("p",null,"Nebula supports compatible schema evolution. This is achieved by two design options"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Every block has its own schema. When a block generated, it will produce a schema based on data and table schema definiton."),(0,l.kt)("li",{parentName:"ul"},"Table schema evolution: a table schema can change time by time, however any changes/updates needs to backward compatible. These changes are legal",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Appending new columns"),(0,l.kt)("li",{parentName:"ul"},"Update columns with compatible types (e.g narrow numbers -> wide numbers, floats -> doubles)"))),(0,l.kt)("li",{parentName:"ul"},"Query system will do best effort to match query schema with block schema, if no compatible data found, NULLs (or default values) will likely be replacement.")),(0,l.kt)("h2",{id:"metadata-system"},"Metadata System"),(0,l.kt)("p",null,"(Placeholder)"),(0,l.kt)("h2",{id:"data-encoding-options"},"Data Encoding Options"),(0,l.kt)("p",null,"Nebula applies different compression and encodings to different data to achieve least cost of memory consumption while achieve best compute efficiency."),(0,l.kt)("p",null,"Here is a list of encodings available for data."),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:"left"},"Type"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Encodings"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Metadata"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"bool"),(0,l.kt)("td",{parentName:"tr",align:"left"},"compressed bitmap"),(0,l.kt)("td",{parentName:"tr",align:"left"},"NULL-MAP")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"integers"),(0,l.kt)("td",{parentName:"tr",align:"left"},"RLE, delta"),(0,l.kt)("td",{parentName:"tr",align:"left"},"min/max/count/sum/HLL")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},"string"),(0,l.kt)("td",{parentName:"tr",align:"left"},"dictionary, inverted index"),(0,l.kt)("td",{parentName:"tr",align:"left"},"index/histogram")))),(0,l.kt)("h1",{id:"ingestion"},"Ingestion"),(0,l.kt)("p",null,"Theoridically, any readable data with schema defined can be ingested by Nebula.\nAnd it is Nebula's goal to cover as many type of data sources as possible to make itself as real data gateway."),(0,l.kt)("p",null,"However, Nebula curently focus on two different data sources"),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},"Static Data (Hive Data)"),(0,l.kt)("li",{parentName:"ol"},"Realtime Data (Kafka Logs)")),(0,l.kt)("p",null,"To illustrate how to configure new data source in Nebula, here are some examples:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-yaml"},'  # single data source swapable when udpates\n  nebula.table1:\n    max-mb: 40000\n    max-hr: 0\n    schema: "ROW<signature:string, user_id:long, comments:string, created_at:string>"\n    data: s3\n    loader: Swap\n    source: s3://<bucket>/nebula/comments/\n    backup: s3://nebula/n101/\n    format: csv | parquet\n    columns:\n      user_id:\n        bloom_filter: true\n      signature:\n        bloom_filter: true\n    time:\n      type: column\n      column: created_at\n      pattern: "%Y-%m-%d %H:%M:%S"\n\n  # rolling data source day by day\n  nebula.table2:\n    max-mb: 200000\n    max-hr: 48\n    schema: "ROW<id:long, user_id:long, link_domain:string, title:string, details:string, signature:string>"\n    data: s3\n    loader: Roll\n    source: s3://<bucket>/nebula/messages/cd=%7Bdate%7D\n    backup: s3://nebula/n103/\n    format: parquet\n    columns:\n      id:\n        bloom_filter: true\n      user_id:\n        bloom_filter: true\n      link_domain:\n        dict: true\n    time:\n      type: macro\n      pattern: date\n\n  # Kafka streams with maximum time to keep\n  k.<topic>:\n    max-mb: 200000\n    max-hr: 12\n    schema: "ROW<userId:long, type:short, statusCode:byte, objectCount:int>"\n    data: kafka\n    topic: <topic>\n    loader: Roll\n    source: <brokers>\n    backup: s3://nebula/n105/\n    format: thrift\n    serde:\n      retention: 90000\n      protocol: binary\n      cmap:\n        _time_: 1\n        userId: 3001\n        type: 3003\n        statusCode: 4002\n        objectCount: 4001\n    columns:\n      userId:\n        bloom_filter: true\n      statusCode:\n        default_value: 0\n      objectCount:\n        default_value: 0\n    time:\n      type: current\n')),(0,l.kt)("p",null,"In Nebula, Ingestion system can run in separate mode which is responsible to deliver data into backup space specified by each table.\nNebula query system will sync data through metadata system."),(0,l.kt)("p",null,"Another mode supported by Nebula is mixed ingestion and query system in the same deployment.\nHoweer, in this case, ingestion tasks share the same compute resources with query system, hence they are in lower priority than query workload."),(0,l.kt)("p",null,"The latter option is usually used for small use cases who don't want multiple cluster setup.\nIngestion system has its own challenges independently from query system. Please refer related posts (future links) to look deeper in this space."))}d.isMDXComponent=!0},2574:function(e,t,a){t.Z=a.p+"assets/images/data.surface-6ae426c3a440db182d5d59855942fed1.png"},6292:function(e,t,a){t.Z=a.p+"assets/images/mem-fdbfeb6c27404e7211d588c9c1125521.png"},2983:function(e,t,a){t.Z=a.p+"assets/images/query-c34af0fc795e9cc1faf08df49721e822.png"},6905:function(e,t,a){t.Z=a.p+"assets/images/type-d705c1975e6a6638a68497e0e432901e.png"}}]);